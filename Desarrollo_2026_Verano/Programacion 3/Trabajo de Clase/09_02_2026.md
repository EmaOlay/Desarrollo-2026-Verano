# Resolución de Ejercicios: Programación Dinámica

Este documento contiene la resolución detallada de los problemas de optimización solicitados, aplicando la técnica de Programación Dinámica según los lineamientos requeridos.

---

## 1. Problema: El Regalo de Darío

**Consigna:** Ana debe comprar una combinación de objetos que cubra exactamente un monto mínimo $M$ o lo supere en forma mínima.

### a) Estrategia de la Solución
Se utiliza un enfoque de **Programación Dinámica (DP) de tipo Bottom-Up**. El problema se modela de forma similar al problema de la suma de subconjuntos (Subset Sum Problem).

* **Elementos requeridos:**
    * **Definición del Estado:** $DP[i]$ es un valor booleano que indica si es posible alcanzar exactamente el monto $i$ utilizando una combinación de los regalos disponibles.
    * **Relación de Recurrencia:** Para cada regalo con precio $p$: $DP[i] = DP[i] \lor DP[i - p]$. Esto significa que el monto $i$ es alcanzable si ya podíamos alcanzar el monto $i - p$.
    * **Caso Base:** $DP[0] = \text{Verdadero}$, ya que siempre es posible gastar 0 pesos (no comprando nada).
    * **Margen de búsqueda:** Dado que buscamos superar el monto mínimo de forma mínima, el arreglo debe extenderse hasta $M + \text{precio\_máximo}$.

### b) Pseudocódigo del Algoritmo
```text
Algoritmo RegaloDario(precios[], montoMinimo)
    n = longitud(precios)
    // El límite superior es el monto mínimo más el regalo más caro posible
    limiteSuperior = montoMinimo + MAX(precios)
    DP = arreglo de booleanos de tamaño [limiteSuperior + 1] inicializado en Falso
    DP[0] = Verdadero

    Para cada p en precios:
        // Iteramos hacia atrás para evitar usar el mismo objeto más de una vez
        Para i desde limiteSuperior hasta p con paso -1:
            Si DP[i - p] es Verdadero:
                DP[i] = Verdadero

    // Buscamos el primer monto alcanzable desde montoMinimo hacia arriba
    Para j desde montoMinimo hasta limiteSuperior:
        Si DP[j] es Verdadero:
            Retornar "El monto mínimo a gastar es: " + j

    Retornar "No se encontró una combinación válida"
FinAlgoritmo
```


# Resolución Ejercicio: Compras en el Shopping (Maximización de Utilidad)

**Problema:** Maximizar la utilidad de la compra de $m$ productos con un presupuesto $K$. Se pueden comprar hasta 3 unidades por producto. La segunda unidad cuesta 1 peso menos y la tercera 2 pesos menos que el precio original ($p_i$).

---

## a) Estrategia de la Solución

Para resolver este problema, utilizamos **Programación Dinámica**. Es una variante del clásico "Problema de la Mochila" (Knapsack Problem), específicamente una mezcla de *Bounded Knapsack* (cantidad limitada) con costos no lineales.

### Elementos de la Programación Dinámica:

1.  **Definición del Estado:**
    Definimos una matriz $DP[i][j]$ donde:
    * $i$ representa que estamos considerando los primeros $i$ productos (del 1 al $m$).
    * $j$ representa el presupuesto actual disponible (de 0 a $K$).
    * El valor $DP[i][j]$ almacena la **máxima utilidad** posible usando un subconjunto de los primeros $i$ productos sin exceder el presupuesto $j$.

2.  **Relación de Recurrencia:**
    Para cada producto $i$, tenemos 4 decisiones posibles (comprar 0, 1, 2 o 3 unidades). Debemos elegir el máximo valor entre estas opciones, siempre que el presupuesto $j$ lo permita.
    
    Sea $p$ el precio base y $u$ la utilidad del producto $i$:
    * **Opción 0 (No comprar):** $DP[i-1][j]$
    * **Opción 1 (1 unidad):** Costo $c_1 = p$.
        $\to DP[i-1][j - c_1] + u$
    * **Opción 2 (2 unidades):** Costo $c_2 = p + (p - 1) = 2p - 1$.
        $\to DP[i-1][j - c_2] + 2u$
    * **Opción 3 (3 unidades):** Costo $c_3 = p + (p - 1) + (p - 2) = 3p - 3$.
        $\to DP[i-1][j - c_3] + 3u$
    
    $$DP[i][j] = \max(Opción_0, Opción_1, Opción_2, Opción_3)$$

3.  **Caso Base:**
    $DP[0][j] = 0$ para todo $0 \le j \le K$. (Con 0 productos, la utilidad es 0).

---

## b) Pseudocódigo del Algoritmo

```text
Algoritmo ShoppingDinámico(K, m, precios[], utilidades[])
    // K: Presupuesto total
    // m: Cantidad de productos disponibles
    // precios[]: Arreglo con los precios base de cada producto (índice 1 a m)
    // utilidades[]: Arreglo con la utilidad de cada producto (índice 1 a m)

    // 1. Inicializar la tabla DP con ceros
    // Tamaño: (m + 1) filas x (K + 1) columnas
    DP = Matriz de enteros de tamaño [m + 1][K + 1] inicializada en 0

    // 2. Rellenar la tabla (Bottom-Up)
    Para i desde 1 hasta m:
        p = precios[i]
        u = utilidades[i]

        // Calcular costos acumulados para este producto
        costo_1_unidad  = p
        costo_2_unidades = p + (p - 1)
        costo_3_unidades = p + (p - 1) + (p - 2)

        Para j desde 0 hasta K:
            // Opción base: No incluir el producto i (hereda el valor anterior)
            max_val = DP[i-1][j]

            // Intentar incluir 1 unidad
            Si j >= costo_1_unidad:
                val1 = DP[i-1][j - costo_1_unidad] + u
                Si val1 > max_val: max_val = val1

            // Intentar incluir 2 unidades
            Si j >= costo_2_unidades:
                val2 = DP[i-1][j - costo_2_unidades] + (2 * u)
                Si val2 > max_val: max_val = val2

            // Intentar incluir 3 unidades
            Si j >= costo_3_unidades:
                val3 = DP[i-1][j - costo_3_unidades] + (3 * u)
                Si val3 > max_val: max_val = val3

            // Guardar el mejor resultado para el estado actual
            DP[i][j] = max_val

    // 3. El resultado final está en la última celda
    Retornar DP[m][K]
FinAlgoritmo